<!DOCTYPE html>
<html>
<meta content="text/html;charset=utf-8" http-equiv="Content-Type">
<meta content="utf-8" http-equiv="encoding">
<head>
  <title>Robot's memories</title>  
  <script src="js/blockly_compressed.js"></script>
  <script src="js/blocks_compressed.js"></script>
  <script src="js/en.js"></script>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <!--p>[created with <a href="https://developers.google.com/blockly/">Blockly</a>]</p-->

  <div id="loading">LOADING...</div>
  <div id="confettis" style="display: inline;">
  </div>

  <div>
  <center>
  <table cols="3" style="width:70%;padding-bottom:2em;">
    <tr>
      <td> <a class="smartButton" href="index.html">HOME</a> </td>
      <td> <b><span id="LEVEL_NUMBER">Level</span></b> </td>
      <td> <a class="smartButton" href="level03.html">-NEXT LEVEL-></a> </td>
    </tr>
  </table>
  </center>    
  </div>    

  <div style="float:left;margin-left:100px;">

    <div id="blocklyDiv" style="height: 480px; width: 600px;"></div>
    <div style="padding-top:.3em;">
      <button class="guiButton" id="loadBlocks">load</button>
      <button class="guiButton" id="saveBlocks">save</button>
      &nbsp &nbsp
      &nbsp &nbsp &nbsp &nbsp
      <button class="guiButton" id="genCode">RUN CODE</button>
      &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp
      &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp
      &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp
      &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp
      <button class="guiButton" id="helpBtn">HELP</button>
    </div>
  </div>
  <div id="theOutputDiv" style="margin-left:100px;height:600px;width:500px;float:left;">
    <canvas id="theCanvas" width="500" height="600"></canvas>
    <div id="theOutputDivText"></div>

  </div>

  <div id="preloaded-images">
     <img width="1" height="1" alt="" id="empty" src="imgs/empty.png">
     <img width="1" height="1" alt="" id="robot" src="imgs/robot.png">
     <img width="1" height="1" alt="" id="arrow" src="imgs/arrow.png">
     <img width="1" height="1" alt="" id="breadleft" src="imgs/bread-1.png">
     <img width="1" height="1" alt="" id="breadright" src="imgs/bread-2.png">

     <img width="1" height="1" alt="" id="salad" src="imgs/salad.png">
     <img width="1" height="1" alt="" id="tomatoes" src="imgs/tomatoes.png">
     <img width="1" height="1" alt="" id="ham" src="imgs/ham.png">

     <img width="1" height="1" alt="" id="saladleaf" src="imgs/salad-leaf.png">
     <img width="1" height="1" alt="" id="tomatoslice" src="imgs/tomato-slice.png">
     <img width="1" height="1" alt="" id="hamslice" src="imgs/ham-slice.png">

     <img width="1" height="1" alt="" id="wall" src="imgs/wall.png">
  </div>


<xml xmlns="http://www.w3.org/1999/xhtml" id="toolbox" style="display: none;">
<block type="GuessRobot"></block>
<block type="forward">
</block>
<block type="turnCW">
</block>
<block type="turnACW">
</block>
<block type="repeat2times">
</block>
<block type="repeat4times">
</block>
<block type="ifLast_turnCW">
   <field name="item">"salad"</field>
</block>
</xml>

  <script src="js/VDSL_Blocks.js"></script>
  <script>
    var toolbox = document.getElementById("toolbox");
    var options = { 
      toolbox : toolbox, 
      collapse : false, 
      comments : false, 
      disable : false, 
      maxBlocks : Infinity, 
      trashcan : true, 
      horizontalLayout : false, 
      toolboxPosition : 'start', 
      css : true, 
      media : 'media/', 
      rtl : false, 
      scrollbars : false, 
      sounds : true, 
      oneBasedIndex : true, 
      grid : {
        spacing : 20, 
        length : 1, 
        colour : '#888', 
        snap : true
      }, 
    };
    var demoWorkspace = Blockly.inject('blocklyDiv',options);
    demoWorkspace.addChangeListener(Blockly.Events.disableOrphans);
  </script> 


  <script src="js/IDSL_def.js"></script>
  <script src="js/javascript_compressed.js"></script>
  
  <script src="js/VDSL_Generators.js"></script>
  <script>const IDSL_name = 'GuessRobot';</script>  

  
  <script src="js/level02_def.js"></script>

  <script>    
    let [ROBOT_LEVELS,LEVEL_NR,GOAL,ACTUAL_GOAL,NBLOCKS_STARS,HELP_MESSAGE] = makeLevel();
    document.getElementById('LEVEL_NUMBER').innerHTML = 'Level '+LEVEL_NR;
    

    const move = {"S":[+1,0],  // row,col
                  "N":[-1,0],
                  "E":[0,+1],
                  "W":[0,-1] }

    function wait(ms) {
        var start = new Date();
        var now;
        while (true) {
            now = new Date();
            if (now - start >= ms) {
                break;
            }
        }
    }

    function listAllBlocks(){
      let dom = Blockly.Xml.workspaceToDom(Blockly.getMainWorkspace());
      let blockList = [];
      function visit(n,level=0){
         blockList.push( '-'.repeat(level) + n.getAttribute("type") );

         // 3 possiblities:
         // 1- a node has 0 children and it's a leaf
         // 2- a node has 1 child, and it's "NEXT"
         // 3- a node has 2 children, a "STATEMENT" and a "NEXT"
         let names = {};
         for (let child of n.children){
            names[child.nodeName] = child;
         }

         let statementChild = names["STATEMENT"];
         if (statementChild)
            visit(statementChild.children[0],level+1);

         let nextChild = names["NEXT"];
         if (nextChild)
            visit(nextChild.children[0],level);
      }

      //console.log("DOM:", dom);
      visit(dom.firstChild);
      blockList.shift();
      return blockList;
    }


    function SAVE_TO_MONGO(victory){
      let blocklyXml = Blockly.Xml.workspaceToDom(Blockly.getMainWorkspace());      
      let text = new XMLSerializer().serializeToString(blocklyXml);

      //console.log(listAllBlocks());
      let data = {"userId": userId,
                      "timeStamp": Date.now(),
                      "timeStampReadable": new Date().toGMTString(),
                      "XMLcode": text,
                      "code": listAllBlocks(),
                      "level":LEVEL_NR,
                      "victory":victory,
                      "nr_stars":numberOfStars|0,
                      "click_times": JSON.stringify(mouseSpy.clicksAt)
                     };
      // *****************************************************
      // dump and reset mouseSpy ;)
      //    time from last click, in ms, and mouse position when clicked
      //console.log( "Mouse data for this run", JSON.stringify(mouseSpy) );
      mouseSpy.clicksAt = [];
      mouseSpy.lastClickTime = new Date().getTime();
      // *****************************************************
      //console.log( saveData );

      // AJAX call to cloud-DB
      var xhr = new XMLHttpRequest();
      xhr.withCredentials = false;
      xhr.addEventListener("readystatechange", function () {
        if (this.readyState === 4) {
          //console.log(this.responseText);
          console.log("attempt saved on cloud DB");
        }
      });
      xhr.open("POST", "https://guessrobot-2e5c.restdb.io/rest/users-solutions");
      xhr.setRequestHeader("content-type", "application/json");
      xhr.setRequestHeader("x-apikey", "60801f0928bf9b609975a4b5");
      xhr.setRequestHeader("cache-control", "no-cache");
      xhr.send(JSON.stringify(data));
    }

    // 0<=t<=1
    const lerp = (v0,v1,t) => {
      return (1-t)*v0+t*v1;
    }

    // if workspace is empty, place a "Start"-block
    if (Blockly.getMainWorkspace().getTopBlocks().length==0){
      //let newBlock = Blockly.Block.obtain(Blockly.getMainWorkspace(),'GuessRobot');
      let newBlock = Blockly.getMainWorkspace().newBlock('GuessRobot');
      newBlock.moveBy(50,50);
      newBlock.initSvg();
      newBlock.render();
      //console.log( newBlock );
    }

    const outputDiv = document.getElementById('theOutputDiv');
    const outputDivText = document.getElementById('theOutputDivText');

    // get the userId
    let userId = localStorage.getItem('userId');
    if (userId==null){
      window.location.replace("index.html"); // redirect if no userId
    }
    //console.log( userId );

////////////////////////////////////////////////////////////////////////////
// draw on canvas, implement movements ...
    let timer = null;
    const canvas = document.getElementById('theCanvas');
      let ctx = canvas.getContext("2d");
      ctx._W = 800;
      ctx._H = 600;
      ctx._X = canvas.offsetLeft;
      ctx._Y = canvas.offsetTop;

    // wait until all images have loaded...
    document.getElementById('loading').style.display = "block";
    let images = new Array(11).fill(null);
    let allImagesLoaded = false;
    while (!allImagesLoaded){
      images = [
        images[ 0] || document.getElementById('empty'),        // # 0
        images[ 1] || document.getElementById('tomatoes'),     // # 1
        images[ 2] || document.getElementById('salad'),        // # 2
        images[ 3] || document.getElementById('ham'),          // # 3
        images[ 4] || document.getElementById('robot'),        // # 4
        images[ 5] || document.getElementById('arrow'),        // 22x34 pixels, # 5
        images[ 6] || document.getElementById('breadleft'),    // # 6
        images[ 7] || document.getElementById('breadright'),   // # 7
        images[ 8] || document.getElementById('tomatoslice'),  // # 8
        images[ 9] || document.getElementById('saladleaf'),    // # 9
        images[10] || document.getElementById('hamslice'),     // # 10
        images[11] || document.getElementById('wall'),         // # 11
      ];
      allImagesLoaded = images.indexOf(null)==-1;
      console.log("loading...");
      wait(100); // ms
    }
    document.getElementById('loading').style.display = "none";

    let numOfBlocksUsed = 0;
    let numberOfStars = null;

    drawLevel = (robot_level,numberOfStars=null)=>{
      let env = robot_level.ENV;
      for (let r=0;r<robot_level.ROWS;r++){
        for (let c=0;c<robot_level.COLS;c++){
          const tile = robot_level.level[r][c];
          if (tile!=0){
            ctx.drawImage(images[0],
                  c*robot_level.kx+robot_level.dx,r*robot_level.ky+robot_level.dy, 
                robot_level.kx,robot_level.ky);
          }
          ctx.drawImage(images[tile],
            c*robot_level.kx+robot_level.dx,r*robot_level.ky+robot_level.dy,
            robot_level.kx,robot_level.ky);
        }     
      }

      // show the number of instructions used
  	  //console.log( "----->" , listAllBlocks() );
  	  if (numOfBlocksUsed>0){
  		ctx.font = "16px Arial";
        	ctx.fillStyle = "black";	  	
  	  	ctx.fillText(`${numOfBlocksUsed} blocks used`,350,52);     
  	  }

      // Show the number of stars obtained in this level -> score
      if (numberOfStars!=null){
        // it means the player has won!
        ctx.font = "20px Arial";
        let stars = '\u2b50'.repeat(numberOfStars) + '\u2605'.repeat(3-numberOfStars);
        ctx.fillText(stars,350,85);

        // (1) create a few confetti-DIVs, (2) move them around, (3) then remove them
        // (1)
        const colorOptions = ["DodgerBlue", "OliveDrab", "Gold", "pink", 
                              "SlateBlue", "lightblue", "Violet", "PaleGreen", 
                              "SteelBlue", "SandyBrown", "Chocolate", "Crimson"];
        for(let i=0;i<32*2;i++) {
          let confettiDiv = document.createElement('div');
          confettiDiv.className = 'confetti rotate';
          confettiDiv.style.left = (ctx._X+350+20)+'px'; // x
          confettiDiv.style.top = (ctx._Y+85)+'px';  // y
          confettiDiv.style.backgroundColor = 
                      colorOptions[~~(Math.random()*colorOptions.length)];
          confettiDiv.style.zIndex = 1000;
          let vx = ~~(Math.cos(i/5)*6);
          let vy = ~~(Math.sin(i/5)*6);
          if (i<32){
            vx = vx / 2;
            vy = vy / 2;
          }
          confettiDiv.setAttribute('data-velocity_x',vx);
          confettiDiv.setAttribute('data-velocity_y',vy);
          document.getElementById('confettis').appendChild(confettiDiv);
        }

        let _t_ = 0;
        let animationTimer = setInterval(()=>{
          if (_t_>=1){
            clearInterval(animationTimer);
            // (3)
            document.querySelectorAll('div.confetti').forEach(function(c){
                c.remove();
            });
          } else {
            // (2)
            document.querySelectorAll('div.confetti').forEach(function(c){
                let x = parseInt(c.style.left);
                let y = parseInt(c.style.top);
                x+=parseFloat(c.getAttribute('data-velocity_x'));
                y+=parseFloat(c.getAttribute('data-velocity_y'));
                c.style.left = (~~x)+'px';
                c.style.top = (~~y)+'px';
                //console.log(c.style);
            });
          }
          _t_ += .04;
        }, 15);

      }

      // arrow showing facing
      ctx.save();
      ctx.translate( (env.pos[1]+.5)*robot_level.kx+robot_level.dx,
                      (env.pos[0]+.5)*robot_level.ky+robot_level.dy );
      if (env.facing=="S") ctx.rotate( 0 );
      if (env.facing=="N") ctx.rotate( Math.PI );
      if (env.facing=="E") ctx.rotate( Math.PI*3/2 );
      if (env.facing=="W") ctx.rotate( Math.PI/2 );
      ctx.drawImage(images[5],
          -robot_level.kx/2+5,robot_level.ky*1/4,
          robot_level.kx-4,robot_level.ky-4); // arrow
      ctx.restore();
      ctx.drawImage(images[4],
          env.pos[1]*robot_level.kx+robot_level.dx+10,env.pos[0]*robot_level.ky+robot_level.dy,
          robot_level.kx*2/3-4,robot_level.ky-4); // robot

      // thinking AKA pick-up area
      // ... for all robots!
      let WHICH_ROBOT = -1;
      for (let robLev of ROBOT_LEVELS){
        WHICH_ROBOT++;
        let down = 32*WHICH_ROBOT;
        ctx.strokeStyle = "black";
        ctx.strokeRect(10-2,35-2+down, 26*12+4,24+4);
        let offset=0;
        for(let think of robLev.ENV.thinking){
          offset++;
          ctx.drawImage(images[think],10+offset*26,35+down, 25,24); // thinking
        }
        ctx.drawImage(images[6],10+(0)*26,35+down ,25,24); // breadleft
        ctx.drawImage(images[7],10+(11)*26,35+down ,25,24); // breadright
      }

      // draw goal
      ctx.font = "16px Arial";
      ctx.fillStyle = "black";
      ctx.fillText("Goal:",20,450+18);
      let goalOffset=-1;
      for(let g of GOAL){
        goalOffset++;
        ctx.drawImage(images[g],70+goalOffset*25,450,50/2,48/2);
      }


      //console.log( ">>>",env.line)
      if (env.line){
        ctx.font = "16px Arial";
        ctx.fillStyle = "black";
        ctx.fillText(env.line[0], 0, 18);
      }

    }

    function drawMultiLevels(param=null){
      ctx.clearRect(0,0,ctx._W,ctx._H);
      for (let robLev of ROBOT_LEVELS){
        drawLevel(robLev,param);
      }
    }
    drawMultiLevels();
////////////////////////////////////////////////////////////////////////////

    document.getElementById('genCode').addEventListener('click' , ()=>{
      if (timer!=null) clearTimeout(timer); // stop execution if it's running

      // unselect all blocks!
      Blockly.getMainWorkspace().getAllBlocks().forEach(b=>b.unselect())
      //Blockly.getMainWorkspace().getTopBlocks()[0].unselect();

      document.getElementById('genCode').disabled = true;

      Blockly.JavaScript.addReservedWords('code');
      let THE_CODE = '';
      var code = 'THE_CODE = '+
        Blockly.JavaScript.workspaceToCode(
        Blockly.getMainWorkspace()) + '.generateCode();';
      //DEBUG console.log( `code:\n${code}` );

      // run the code using the actual IDSL
      try {
        eval(code);
      } catch (error) {
        console.log(error);
        document.getElementById('genCode').disabled = false;
      }

      if (THE_CODE.length==0){
        document.getElementById('genCode').disabled = false;
        return; // there is nothing to do!
      }

      // ------ execute the robots ----------------------------
      // DEBUG console.log( "--->",THE_CODE );

    let ctx = canvas.getContext("2d");
    ctx._W = 800;
    ctx._H = 600;

    let SPEED = 1000; //300;//1000;
    let MAX_STEPS = 100;
    let progCount = 0;

    // reset all robots
    for (let robLev of ROBOT_LEVELS)
      robLev.ENV = {facing:"S",pos:robLev.robotPos,thinking:[],line:null};

    let step = (code)=>{
      numOfBlocksUsed = listAllBlocks().length;
      let instr = code[progCount];

    // start for -----------------------------------------
    let WHICH_ROBOT = -1;
    let whatToAnimate = []; // queue of animations for this step, for all existing robots
    for (let ROBOT_LEVEL of ROBOT_LEVELS){
      WHICH_ROBOT+=1;
      ROBOT_LEVEL.ENV.line = instr;
      // console.log( "+++>", progCount , instr , ENV);
        switch (instr[0]){
          case 'forward': {
            let [dx,dy] = move[ROBOT_LEVEL.ENV.facing];
            let [x,y] = ROBOT_LEVEL.ENV.pos;
            x += dx;
            y += dy;
            if (x<0) x+=ROBOT_LEVEL.ROWS;
            if (x>=ROBOT_LEVEL.ROWS) x-=ROBOT_LEVEL.ROWS;
            if (y<0) y+=ROBOT_LEVEL.COLS;
            if (y>=ROBOT_LEVEL.COLS) y-=ROBOT_LEVEL.COLS;

//            console.log( ROBOT_LEVEL.level,x,y );
            // wall collision
            if (ROBOT_LEVEL.level[x][y]==11){ // the wall!
              // don'n walk, just stay
              break;
            } 

            // remember what to animate ------ START
            // only when entering a tile while going FD!
            let steppingOn = ROBOT_LEVEL.level[x][y];
            //console.log( "steppingOn" , steppingOn );
            if (steppingOn!=0){
              steppingOn = steppingOn+7; // instead of salad -> salad-leaf
            }

            whatToAnimate.push([
                  WHICH_ROBOT,
                  ROBOT_LEVEL.ENV.pos[0],ROBOT_LEVEL.ENV.pos[1],x,y,
                  steppingOn
            ]);
            // remember what to animate ------ STOP

          } break;
          case 'turncw': {
            console.log("turn");
            if (ROBOT_LEVEL.ENV.facing=="S"){ 
              ROBOT_LEVEL.ENV.facing = "W"; 
            } else if (ROBOT_LEVEL.ENV.facing=="W"){
              ROBOT_LEVEL.ENV.facing = "N";
            } else if (ROBOT_LEVEL.ENV.facing=="N"){ 
              ROBOT_LEVEL.ENV.facing = "E"; 
            } else if (ROBOT_LEVEL.ENV.facing=="E"){ 
              ROBOT_LEVEL.ENV.facing = "S"; 
            }
          } break;
          case 'turnacw': {
            console.log("turning anticlockwise");
            if (ROBOT_LEVEL.ENV.facing=="S"){ 
              ROBOT_LEVEL.ENV.facing = "E"; 
            } else if (ROBOT_LEVEL.ENV.facing=="E"){
              ROBOT_LEVEL.ENV.facing = "N";
            } else if (ROBOT_LEVEL.ENV.facing=="N"){ 
              ROBOT_LEVEL.ENV.facing = "W"; 
            } else if (ROBOT_LEVEL.ENV.facing=="W"){ 
              ROBOT_LEVEL.ENV.facing = "S"; 
            }
          } break;          
          case 'repeat2times': {
            //console.log("=====>",code , instr[1]);
            code.splice(progCount,1, ...instr[1],...instr[1]);
            progCount--;
          } break;
          case 'repeat4times': {
            //console.log("=====>",code , instr[1]);
            code.splice(progCount,1, ...instr[1],
                                     ...instr[1],
                                     ...instr[1],
                                     ...instr[1]);
            progCount--;
          } break;
          case 'ifLast_turnCW': {
            const index = ["tomato","salad","ham"].indexOf(instr[1]) + 8;
            let l = ROBOT_LEVEL.ENV.thinking.length;
            if (l!=0){
              let think = ROBOT_LEVEL.ENV.thinking[l-1]; // the LAST thing you are thinking!
              // DEBUG console.log( "----->",index, ' vs ' , think);

              if (think==index){
                console.log("turn");
                if (ROBOT_LEVEL.ENV.facing=="S"){ 
                  ROBOT_LEVEL.ENV.facing = "W"; 
                } else if (ROBOT_LEVEL.ENV.facing=="W"){
                  ROBOT_LEVEL.ENV.facing = "N";
                } else if (ROBOT_LEVEL.ENV.facing=="N"){ 
                  ROBOT_LEVEL.ENV.facing = "E"; 
                } else if (ROBOT_LEVEL.ENV.facing=="E"){ 
                  ROBOT_LEVEL.ENV.facing = "S"; 
                }                
              }
            }
          } break;          
        }

  } // end for -----------------------------------------

  if (whatToAnimate.length>0){
    //  whatToAnimate  is array of [ robotId,
    //                               ROBOT_LEVEL.ENV.pos[0],ROBOT_LEVEL.ENV.pos[1],x,y
    //                               whatTheRobotIsSteppingOn ]

    let thenDo = ()=>{
      let _t_ = 0;
      let TIMER2 = setInterval(()=>{
        if (_t_>=1){ // when done...
          clearInterval(TIMER2);
          for (let i=0;i<whatToAnimate.length;i++){
            let [robotId,x1,y1,x2,y2,steppingOn] = whatToAnimate[i];            
            if (steppingOn!=0){
              ROBOT_LEVELS[robotId].ENV.thinking.push(steppingOn); // finally add to the list!
            }
          }
        } else {
          drawMultiLevels();
          for (let i=0;i<whatToAnimate.length;i++){
            let WHICH_ROBOT = i;
            let robotId = whatToAnimate[i][0];
            let steppingOn = whatToAnimate[i][5];

            let offset = ROBOT_LEVELS[robotId].ENV.thinking.length;
            let [x1,y1,x2,y2] = [
                ROBOT_LEVELS[robotId].ENV.pos[1]*ROBOT_LEVELS[robotId].kx+ROBOT_LEVELS[robotId].dx,
                ROBOT_LEVELS[robotId].ENV.pos[0]*ROBOT_LEVELS[robotId].ky+ROBOT_LEVELS[robotId].dy,
                5+(1+offset)*26,28 +32*WHICH_ROBOT 
            ];

            if (steppingOn!=0){
              ctx.drawImage(images[steppingOn],
                  lerp(x1,x2,_t_) , lerp(y1,y2,_t_),
                  lerp(ROBOT_LEVELS[robotId].kx*2/3,25,_t_),
                  lerp(ROBOT_LEVELS[robotId].ky*2/3,24,_t_) );
            }
          }
        }
        _t_ += .04;
      }, 15); 
    };  // end of thenDo


    let _t_ = 0;
    let TIMER = setInterval(()=>{
      if (_t_>=1){
        clearInterval(TIMER);
        for (let i=0;i<whatToAnimate.length;i++){ // just to be sure!
          let robotId = whatToAnimate[i][0];
          let [x,y] = ROBOT_LEVELS[robotId].ENV.pos;
          ROBOT_LEVELS[robotId].ENV.pos[0] = Math.round(x);
          ROBOT_LEVELS[robotId].ENV.pos[1] = Math.round(y);
        }
        thenDo();
      } else {
        for (let i=0;i<whatToAnimate.length;i++){
          let [robotId,x1,y1,x2,y2,steppingOn] = whatToAnimate[i];
          ROBOT_LEVELS[robotId].ENV.pos = [ lerp(x1,x2,_t_) , lerp(y1,y2,_t_) ];
        }
        drawMultiLevels();
      }
      _t_ += .1;
    }, 15);
    // **************************************
  }


      drawMultiLevels();

      progCount++;
      if (progCount<code.length){
        timer = setTimeout(()=>step(code), SPEED);
      } else {
      	timer = setTimeout(()=>{
          let victory = "you lost!";
          numberOfStars = null;

          let allRobotsReachGoal = true;
          for (let robLev of ROBOT_LEVELS){
            if (robLev.ENV.thinking.join('')!=ACTUAL_GOAL.join('')){
              allRobotsReachGoal = false;
              break;
            }
          }
          if (allRobotsReachGoal){            
            victory = "you WON! ^_^ ";
  
            // decide how many starts player gets!
            numberOfStars = 1;
            if (numOfBlocksUsed <= NBLOCKS_STARS[0]){
              numberOfStars = 2;
            }
            if (numOfBlocksUsed <= NBLOCKS_STARS[1]){
              numberOfStars = 3;
            }

            SAVE_TO_MONGO(true); // post solution to MongoDB
          } else {
            SAVE_TO_MONGO(false); // post solution to MongoDB
          }

          for (let robLev of ROBOT_LEVELS){
            robLev.ENV.line = null; // no instruction to show
          }
          
          console.log( "numberOfStars" , numberOfStars );
          // draw the stars, juice them up!!
          drawMultiLevels(numberOfStars);
          
          document.getElementById('genCode').disabled = false;

          setTimeout(()=>alert("Execution terminated ..." + victory),800);
	      },SPEED);
	    
      }
    }
    
    drawMultiLevels();
    //drawLevel(ROBOT_LEVEL);

    timer = setTimeout(()=>{ step(THE_CODE); }, 100);
  });


    document.getElementById('helpBtn').addEventListener('click' , ()=>{
      alert(HELP_MESSAGE);
    });

    // save workspace blocks to file
    document.getElementById('saveBlocks').addEventListener('click' , ()=>{    
      let blocklyXml = Blockly.Xml.workspaceToDom(Blockly.getMainWorkspace());      
      var xmlText = new XMLSerializer().serializeToString(blocklyXml);
      // DEGUB console.log( xmlText );


      let yes = true;
      let name = prompt('[SAVING]\nName your project:',IDSL_name+'_savedXML');
      if (localStorage.getItem(name)!=null){
        yes = confirm("Do you want to lose previously saved workspace?");
      }
      if (yes){
        alert('Saved');
        localStorage.setItem(name,xmlText);
      }
  });

    // load blocks back from file
    document.getElementById('loadBlocks').addEventListener('click' , ()=>{  
      let name = prompt('[LOADING]\nWhich project:',IDSL_name+'_savedXML');
      if (name==null){ // user pressed "cancel" 
      	return;
  	  }
  	  
      let xmlText = localStorage.getItem(name); 
      if (xmlText==null){
        alert('There is nothing saved to reload...');
        return;
      }
      let blocklyXml = Blockly.Xml.textToDom(xmlText);
      console.log( 'loading ... ' ); // DEGUB + xmlText);
      // DEGUB console.log( blocklyXml);

      let workspace = Blockly.getMainWorkspace();
      // DEGUB console.log( workspace );
      
      workspace.clear();
      Blockly.Xml.domToWorkspace(blocklyXml, workspace);
      //Blockly.Xml.appendDomToWorkspace(blocklyXml, workspace);
    });


    // ************** spy every mouse click *****************
    let mouseSpy = {
        clicksAt: [],
        lastClickTime: new Date().getTime()};
    document.body.addEventListener("click",(evt)=>{
        let t = new Date().getTime();
        let dt = t - mouseSpy.lastClickTime;
        mouseSpy.clicksAt.push([dt/1000,[evt.clientX,evt.clientY]]);
        mouseSpy.lastClickTime = t;
    });

  </script>

</body>
</html>